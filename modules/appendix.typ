#import "@preview/subpar:0.2.0"

= Supplementary Material Images

#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/0/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/1/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/2/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/3/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/4/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/5/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/6/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/7/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/8/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/9/v1/correlation/metrics.png", height: 45%)),
  outlined: false,
)
#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/10/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/11/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/12/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/13/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/14/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/15/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/16/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/17/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/18/v1/correlation/metrics.png", height: 45%)),
  figure(image("../data/6/19/v1/correlation/metrics.png", height: 45%)),
  numbering: (..nums) => [#counter(figure.where(outlined: true)).display((..num_figs)=>num_figs.pos().at(0))],
  caption: [
    All results for MAE, MSE, RMSE and R2.
  ],
)


#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/0/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/1/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/2/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/3/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/4/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/5/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/6/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/7/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/8/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/9/v1/correlation/pearson.png", height: 45%)),
  outlined: false,
)
#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/10/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/11/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/12/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/13/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/14/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/15/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/16/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/17/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/18/v1/correlation/pearson.png", height: 45%)),
  figure(image("../data/6/19/v1/correlation/pearson.png", height: 45%)),
  numbering: (..nums) => [#counter(figure.where(outlined: true)).display((..num_figs)=>num_figs.pos().at(0))],
  caption: [
    All results for Pearson Metric.
  ],
)


#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/0/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/1/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/2/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/3/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/4/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/5/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/6/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/7/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/8/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/9/v1/correlation/regression.png", height: 45%)),
  outlined: false,
)
#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/10/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/11/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/12/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/13/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/14/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/15/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/16/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/17/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/18/v1/correlation/regression.png", height: 45%)),
  figure(image("../data/6/19/v1/correlation/regression.png", height: 45%)),
  numbering: (..nums) => [#counter(figure.where(outlined: true)).display((..num_figs)=>num_figs.pos().at(0))],
  caption: [
    All results for Linear Regression.
  ],
)

#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/0/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/1/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/2/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/3/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/4/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/5/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/6/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/7/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/8/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/9/v1/correlation/spearman.png", height: 45%)),
  outlined: false,
)
#subpar.grid(
  columns: 5,
  gutter: 4mm,
  figure(image("../data/6/10/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/11/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/12/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/13/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/14/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/15/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/16/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/17/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/18/v1/correlation/spearman.png", height: 45%)),
  figure(image("../data/6/19/v1/correlation/spearman.png", height: 45%)),
  numbering: (..nums) => [#counter(figure.where(outlined: true)).display((..num_figs)=>num_figs.pos().at(0))],
  caption: [
    All results for the Spearman Metric.
  ],
)





= Supplementary Material Source Code
#heading(depth: 5, numbering: none, bookmarked: false)[Strategy Base Class]
```python
class Strategy:
  def __init__(self, n=None, m=None):
    self.n = n
    self.m = m

  def get_points(self, surfaces):
    raise NotImplementedError("Subclasses must implement get_points")

  def get_sam_inputs(self, surfaces):
    input_point_lists = self.get_points(surfaces)

    # Initialize empty lists
    input_points = []
    input_label = []

    for i, input_points_per_surface in enumerate(input_point_lists):
      # Predefine structures
      current_points = np.empty((0, 2), dtype=int)
      current_label = np.empty(0, dtype=int)

      for row, col in input_points_per_surface:
        current_points = np.append(current_points, [[col, row]], axis=0)
        current_label = np.append(current_label, [1])

      input_points.append(current_points)
      input_label.append(current_label)

    return input_points, input_label

  def is_non_edge_point(self, row, col, surface):
    # Check if point is in surface
    if (row, col) not in surface:
      return False
    # If any neighbour is not in surface this is an edge
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
      if (row + dr, col + dc) not in surface:
        return False

    return True
```

#heading(depth: 5, numbering: none, bookmarked: false)[Random Point Strategy]
```python
class Random(Strategy):
  def __init__(self, n=1):
    super().__init__(n=n, m=None)

  def get_points(self, surfaces):
    points = []
    for surface in surfaces:
      current_points = []

      # Find all valid points
      valid_points = []
      for row, col in surface:
        if self.is_non_edge_point(row, col, surface):
          valid_points.append((row, col))

      # Append n valid points
      for _ in range(self.n):
        if not valid_points:
          break
        random_index = random.randint(0, len(valid_points) - 1)
        current_points.append(valid_points[random_index])
        valid_points.pop(random_index)
      points.append(current_points)

    return points
```

#heading(depth: 5, numbering: none, bookmarked: false)[Center Point Strategy]
```python
class Center(Strategy):
  def __init__(self, n=1):
    super().__init__(n=n, m=None)

  def get_points(self, surfaces):
    points = []
    for surface in surfaces:
      rows, cols = zip(*surface)
      if rows and cols:
        # Bounds
        min_row, max_row = min(rows), max(rows)
        min_col, max_col = min(cols), max(cols)

        # Calculate row, column grid from n
        num_rows = int(np.sqrt(self.n))
        num_cols = int(np.ceil(self.n / num_rows))

        # Step size
        rs = 1 / (num_rows + 1)
        cs = 1 / (num_cols + 1)

        current_points = []
        for r in np.linspace(0, 1, num_rows + 2)[1:-1]:
          for c in np.linspace(0, 1, num_cols + 2)[1:-1]:
            # Define current grid cell boundaries
            cr_min = int(min_row + (max_row - min_row) * (r - rs / 2))
            cr_max = int(min_row + (max_row - min_row) * (r + rs / 2))
            cc_min = int(min_col + (max_col - min_col) * (c - cs / 2))
            cc_max = int(min_col + (max_col - min_col) * (c + cs / 2))

            # Calculate frequency distribution for the current grid cell
            freq_r = {}
            freq_c = {}
            for row, col in surface:
              if cr_min <= row <= cr_max and cc_min <= col <= cc_max:
                freq_r[row] = freq_r.get(row, 0) + 1
                freq_c[col] = freq_c.get(col, 0) + 1

            # Weighted average for center_row within the grid cell
            wrs = sum(row * freq for row, freq in freq_r.items())
            center_row = int(wrs / sum(freq_r.values()))

            # Weighted average for center_col within the grid cell
            wcs = sum(col * freq for col, freq in freq_c.items())
            center_col = int(wcs / sum(freq_c.values()))
            
            # If the current point is valid, append it
            if self.is_non_edge_point(center_row, center_col, surface):
              current_points.append((center_row, center_col))
            else:
              # If not in surface, move to closest surface point
              if (center_row, center_col) not in surface:
                closest_point = None
                min_dist = float('inf')
                for row, col in surface:
                  x = (row - center_row)**2 + (col - center_col)**2
                  d = np.sqrt(x)
                  if d < min_dist:
                    min_dist = d
                    closest_point = (row, col)
                center_row, center_col = closest_point

              # Search for a valid adjacent point iteratively
              queue = [(center_row, center_col)]
              visited = set()
              while queue:
                row, col = queue.pop(0)

                if self.is_non_edge_point(row, col, surface):
                  current_points.append((row, col))
                  break

                visited.add((row, col))
                # Add unvisited neighbors to the queue
                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                  nr = row + dr
                  nc = col + dc

                  if (nr, nc) in surface and (nr, nc) not in visited:
                    queue.append((nr, nc))
        points.append(current_points)

    # Remove duplicates
    points = [list(set(point_list)) for point_list in points]
    return points
```

#heading(depth: 5, numbering: none, bookmarked: false)[Combined Strategy]
```python
class Combined(Strategy):
  def __init__(self, n=3, m=10):
    super().__init__(n, m)

  def get_sam_inputs(self, surfaces):
    positive_points_list = Center(n=self.n).get_points(surfaces)
    negative_points_list = Center(n=1).get_points(surfaces)

    input_points, input_label = [], []
    # Positive points
    for i, positive_points in enumerate(positive_points_list):
      current_points = np.empty((0, 2), dtype=int)
      current_labels = np.empty(0, dtype=int)
      for row, col in positive_points:
        current_points = np.append(current_points, [[col, row]], axis=0)
        current_labels = np.append(current_labels, [1])

      # Negative points
      added_negatives = 0
      for j, negative_points in enumerate(negative_points_list):
        if i != j and negative_points:
          row, col = negative_points[0]
          current_points = np.append(current_points, [[col, row]], axis=0)
          current_labels = np.append(current_labels, [0])

          added_negatives += 1
          if added_negatives >= self.m:
            break

      input_points.append(current_points)
      input_label.append(current_labels)

    return input_points, input_label
```